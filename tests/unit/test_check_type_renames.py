"""Test file for Issue #170.

Generated by AssemblyZero TDD Testing Workflow.
Tests will fail with ImportError until implementation exists (TDD RED phase).
"""

import logging
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch

import pytest

from assemblyzero.nodes.check_type_renames import (
    OrphanedUsage,
    TypeRenameCheckResult,
    TypeRenameIssue,
    check_type_renames,
    extract_removed_types,
    find_type_usages,
    format_type_rename_error,
    log_scan_summary,
)


# Fixtures
@pytest.fixture
def mock_external_service():
    """Mock external service for isolation."""
    yield None


@pytest.fixture
def sample_diff_class_removed():
    """Diff with a removed class."""
    return """--- a/mymodule.py
+++ b/mymodule.py
@@ -1,5 +1,3 @@
-class Foo:
-    pass
 
 def bar():
     pass
"""


@pytest.fixture
def sample_diff_typeddict_removed():
    """Diff with a removed TypedDict."""
    return """--- a/types.py
+++ b/types.py
@@ -1,5 +1,3 @@
-Bar = TypedDict('Bar', {'name': str})
-
 def something():
     pass
"""


@pytest.fixture
def sample_diff_type_alias_removed():
    """Diff with a removed type alias."""
    return """--- a/aliases.py
+++ b/aliases.py
@@ -1,5 +1,3 @@
-MyType = Union[str, int]
-
 def func():
     pass
"""


@pytest.fixture
def sample_diff_clean():
    """Diff with no type removals."""
    return """--- a/file.py
+++ b/file.py
@@ -1,3 +1,3 @@
 def foo():
-    return 1
+    return 2
"""


# Unit Tests
def test_id():
    """Placeholder test for test ID generation."""
    # This test verifies the test infrastructure is working
    assert True


def test_t010(sample_diff_class_removed):
    """test_extract_removed_class | Extracts class name from diff | RED"""
    result = extract_removed_types(sample_diff_class_removed)
    
    assert len(result) == 1
    assert result[0][0] == "Foo"
    assert result[0][1] == "mymodule.py"


def test_t020(sample_diff_typeddict_removed):
    """test_extract_removed_typeddict | Extracts TypedDict from diff | RED"""
    result = extract_removed_types(sample_diff_typeddict_removed)
    
    assert len(result) == 1
    assert result[0][0] == "Bar"
    assert result[0][1] == "types.py"


def test_t030(sample_diff_type_alias_removed):
    """test_extract_removed_type_alias | Extracts type alias from diff | RED"""
    result = extract_removed_types(sample_diff_type_alias_removed)
    
    assert len(result) == 1
    assert result[0][0] == "MyType"
    assert result[0][1] == "aliases.py"


@patch('subprocess.run')
def test_t040(mock_run):
    """test_find_usages_in_imports | Finds orphaned import statements | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/main.py:5:from mymodule import Foo\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], [])
    
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/main.py"
    assert usages[0]["line_number"] == 5
    assert "from mymodule import Foo" in usages[0]["line_content"]


@patch('subprocess.run')
def test_t050(mock_run):
    """test_find_usages_in_annotations | Finds orphaned type annotations | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/func.py:10:def process(data: Foo) -> None:\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], [])
    
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/func.py"
    assert usages[0]["line_number"] == 10
    assert "def process(data: Foo)" in usages[0]["line_content"]


@patch('subprocess.run')
def test_t060(mock_run):
    """test_excludes_docs_directory | Does not flag docs references | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="docs/api.md:20:The Foo class does something\nsrc/main.py:5:from mymodule import Foo\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], ["docs/"])
    
    # Should only find the src file, not the docs file
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/main.py"


@patch('subprocess.run')
def test_t070(mock_run):
    """test_excludes_lineage_directory | Does not flag lineage references | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="lineage/old.py:15:class Foo:\nsrc/main.py:5:from mymodule import Foo\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], ["lineage/"])
    
    # Should only find the src file, not the lineage file
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/main.py"


@patch('subprocess.run')
def test_t080(mock_run, sample_diff_class_removed):
    """test_full_workflow_pass | Passes when all usages updated | RED"""
    # Mock git diff
    mock_run.side_effect = [
        Mock(returncode=0, stdout=sample_diff_class_removed),  # git diff
        Mock(returncode=0, stdout="/repo"),  # git rev-parse
        Mock(returncode=1, stdout=""),  # git grep (no matches)
    ]
    
    state = {}
    result = check_type_renames(state, timeout=10.0)
    
    assert result["type_rename_check_passed"] is True
    assert result["type_rename_issues"] == []


@patch('subprocess.run')
def test_t090(mock_run, sample_diff_class_removed):
    """test_full_workflow_fail | Fails when orphaned usages exist | RED"""
    # Mock git diff and grep with orphaned usage
    mock_run.side_effect = [
        Mock(returncode=0, stdout=sample_diff_class_removed),  # git diff
        Mock(returncode=0, stdout="/repo"),  # git rev-parse
        Mock(returncode=0, stdout="src/main.py:5:from mymodule import Foo\n"),  # git grep
    ]
    
    state = {}
    result = check_type_renames(state, timeout=10.0)
    
    assert result["type_rename_check_passed"] is False
    assert len(result["type_rename_issues"]) == 1
    assert result["type_rename_issues"][0]["old_name"] == "Foo"


def test_t100():
    """test_error_message_format | Error includes file, line, content | RED"""
    issues = [
        TypeRenameIssue(
            old_name="Foo",
            definition_file="mymodule.py",
            orphaned_usages=[
                OrphanedUsage(
                    file_path="src/main.py",
                    line_number=5,
                    line_content="from mymodule import Foo"
                )
            ]
        )
    ]
    
    message = format_type_rename_error(issues)
    
    assert "Foo" in message
    assert "mymodule.py" in message
    assert "src/main.py:5" in message
    assert "from mymodule import Foo" in message


@patch('subprocess.run')
def test_t110(mock_run):
    """test_timeout_enforcement | Raises TimeoutError when timeout exceeded | RED"""
    import subprocess
    
    mock_run.side_effect = subprocess.TimeoutExpired(cmd=['git', 'grep'], timeout=0.1)
    
    with pytest.raises(TimeoutError, match="exceeded.*timeout"):
        find_type_usages("Foo", [Path("/repo")], [], timeout=0.1)


def test_t120(caplog):
    """test_log_scan_summary | Logs removed type count and files scanned | RED"""
    with caplog.at_level(logging.INFO):
        log_scan_summary(removed_types_count=3, files_scanned=10, issues_found=2)
    
    assert "Removed types detected: 3" in caplog.text
    assert "Files scanned: 10" in caplog.text
    assert "Orphaned usage issues: 2" in caplog.text


def test_010(sample_diff_class_removed):
    """Extract removed class | Auto | Diff with `-class Foo:` | `[("Foo", "file.py")]` | Correct extraction"""
    result = extract_removed_types(sample_diff_class_removed)
    
    assert len(result) == 1
    type_name, file_name = result[0]
    assert type_name == "Foo"
    assert file_name == "mymodule.py"


def test_020(sample_diff_typeddict_removed):
    """Extract TypedDict | Auto | Diff with `-Bar = TypedDict` | `[("Bar", "file.py")]` | Correct extraction"""
    result = extract_removed_types(sample_diff_typeddict_removed)
    
    assert len(result) == 1
    type_name, file_name = result[0]
    assert type_name == "Bar"
    assert file_name == "types.py"


def test_030(sample_diff_type_alias_removed):
    """Extract type alias | Auto | Diff with `-MyType = Union[...]` | `[("MyType", "file.py")]` | Correct extraction"""
    result = extract_removed_types(sample_diff_type_alias_removed)
    
    assert len(result) == 1
    type_name, file_name = result[0]
    assert type_name == "MyType"
    assert file_name == "aliases.py"


@patch('subprocess.run')
def test_040(mock_run):
    """Find import usages | Auto | Codebase with `from x import Foo` | Usage detected | Found with location"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/main.py:5:from x import Foo\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], [])
    
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/main.py"
    assert usages[0]["line_number"] == 5


@patch('subprocess.run')
def test_050(mock_run):
    """Find annotation usages | Auto | Codebase with `def f(x: Foo)` | Usage detected | Found with location"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/func.py:10:def f(x: Foo):\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], [])
    
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/func.py"
    assert usages[0]["line_number"] == 10


@patch('subprocess.run')
def test_060(mock_run, mock_external_service):
    """Exclude docs | Auto | Usage in `docs/api.md` | Not reported | No false positive"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="docs/api.md:20:Foo class reference\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], ["docs/"])
    
    assert len(usages) == 0


@patch('subprocess.run')
def test_070(mock_run):
    """Exclude lineage | Auto | Usage in `lineage/old.py` | Not reported | No false positive"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="lineage/old.py:15:class Foo:\n"
    )
    
    usages = find_type_usages("Foo", [Path("/repo")], ["lineage/"])
    
    assert len(usages) == 0


@patch('subprocess.run')
def test_080(mock_run, sample_diff_class_removed):
    """Clean rename passes | Auto | All usages updated | `passed=True` | Workflow continues"""
    mock_run.side_effect = [
        Mock(returncode=0, stdout=sample_diff_class_removed),  # git diff
        Mock(returncode=0, stdout="/repo"),  # git rev-parse
        Mock(returncode=1, stdout=""),  # git grep (no matches)
    ]
    
    state = {}
    result = check_type_renames(state, timeout=10.0)
    
    assert result["type_rename_check_passed"] is True


@patch('subprocess.run')
def test_090(mock_run, sample_diff_class_removed):
    """Orphaned usage fails | Auto | Missed usage exists | `passed=False` | Workflow stops"""
    mock_run.side_effect = [
        Mock(returncode=0, stdout=sample_diff_class_removed),  # git diff
        Mock(returncode=0, stdout="/repo"),  # git rev-parse
        Mock(returncode=0, stdout="src/main.py:5:from mymodule import Foo\n"),  # git grep
    ]
    
    state = {}
    result = check_type_renames(state, timeout=10.0)
    
    assert result["type_rename_check_passed"] is False


def test_100():
    """Error message quality | Auto | One orphaned usage | Message has file:line | Actionable output"""
    issues = [
        TypeRenameIssue(
            old_name="Foo",
            definition_file="mymodule.py",
            orphaned_usages=[
                OrphanedUsage(
                    file_path="src/main.py",
                    line_number=5,
                    line_content="from mymodule import Foo"
                )
            ]
        )
    ]
    
    message = format_type_rename_error(issues)
    
    assert "src/main.py:5" in message
    assert "from mymodule import Foo" in message


@patch('subprocess.run')
def test_110(mock_run, mock_external_service):
    """Timeout enforcement | Auto | Mock slow grep (>10s) | TimeoutError raised | Fail-safe works"""
    import subprocess
    
    mock_run.side_effect = subprocess.TimeoutExpired(cmd=['git', 'grep'], timeout=10.0)
    
    with pytest.raises(TimeoutError):
        find_type_usages("Foo", [Path("/repo")], [], timeout=10.0)


def test_120(caplog):
    """Observability logging | Auto | Normal execution | Log contains counts | Debugging enabled"""
    with caplog.at_level(logging.INFO):
        log_scan_summary(removed_types_count=5, files_scanned=20, issues_found=3)
    
    log_text = caplog.text
    assert "5" in log_text
    assert "20" in log_text
    assert "3" in log_text