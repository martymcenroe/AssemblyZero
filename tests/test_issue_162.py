"""Test file for Issue #162.

Generated by AssemblyZero TDD Testing Workflow.
Tests automatic commit and push functionality in requirements workflow.
"""

import pytest
import subprocess
from pathlib import Path
from unittest.mock import Mock, patch, call
from assemblyzero.workflows.requirements.git_operations import (
    format_commit_message,
    commit_and_push,
    GitOperationError,
)
from assemblyzero.workflows.requirements.state import create_initial_state
from assemblyzero.workflows.requirements.nodes.finalize import (
    finalize,
    _commit_and_push_files,
)


# Unit Tests
# -----------

def test_010(tmp_path):
    """
    Happy path LLD commit | Auto | state with LLD files | Commit created,
    pushed | Commit SHA returned; files in remote
    """
    # TDD: Arrange
    created_files = ["docs/lld/active/LLD-162.md", "docs/lld/lld-status.json"]
    
    with patch("subprocess.run") as mock_run:
        # Mock git add (called twice)
        # Mock git commit
        # Mock git push
        mock_run.side_effect = [
            Mock(returncode=0, stdout="", stderr=""),  # git add file 1
            Mock(returncode=0, stdout="", stderr=""),  # git add file 2
            Mock(returncode=0, stdout="[main abc123] docs: add LLD-162 via requirements workflow\n", stderr=""),  # git commit
            Mock(returncode=0, stdout="", stderr=""),  # git push
        ]
        
        # TDD: Act
        commit_sha = commit_and_push(
            created_files=created_files,
            workflow_type="lld",
            target_repo=tmp_path,
            issue_number=162,
        )
        
        # TDD: Assert
        assert commit_sha == "abc123"
        assert mock_run.call_count == 4
        
        # Verify git add was called for each file
        assert mock_run.call_args_list[0][0][0] == ["git", "add", "docs/lld/active/LLD-162.md"]
        assert mock_run.call_args_list[1][0][0] == ["git", "add", "docs/lld/lld-status.json"]
        
        # Verify git commit (includes "Ref #N" footer - NOT "Closes" since LLD is design only)
        assert mock_run.call_args_list[2][0][0] == ["git", "commit", "-m", "docs: add LLD-162 via requirements workflow\n\nRef #162"]
        
        # Verify git push
        assert mock_run.call_args_list[3][0][0] == ["git", "push"]


def test_020(tmp_path):
    """
    Happy path issue commit | Auto | state with lineage files | Commit
    created, pushed | Commit SHA returned; message format correct
    """
    # TDD: Arrange
    created_files = ["docs/lineage/active/my-feature/001-final.md"]
    
    with patch("subprocess.run") as mock_run:
        mock_run.side_effect = [
            Mock(returncode=0, stdout="", stderr=""),  # git add
            Mock(returncode=0, stdout="[main def456] docs: add lineage for my-feature via requirements workflow\n", stderr=""),  # git commit
            Mock(returncode=0, stdout="", stderr=""),  # git push
        ]
        
        # TDD: Act
        commit_sha = commit_and_push(
            created_files=created_files,
            workflow_type="issue",
            target_repo=tmp_path,
            slug="my-feature",
        )
        
        # TDD: Assert
        assert commit_sha == "def456"
        
        # Verify commit message format (index 3 is the message after ["git", "commit", "-m", message])
        commit_call = mock_run.call_args_list[1]
        assert commit_call[0][0][3] == "docs: add lineage for my-feature via requirements workflow"


def test_030(tmp_path):
    """
    Empty created_files | Auto | state with empty list | No commit, no
    error | Function returns without git operations
    """
    # TDD: Arrange
    created_files = []
    
    with patch("subprocess.run") as mock_run:
        # TDD: Act
        commit_sha = commit_and_push(
            created_files=created_files,
            workflow_type="lld",
            target_repo=tmp_path,
            issue_number=162,
        )
        
        # TDD: Assert
        assert commit_sha == ""
        assert mock_run.call_count == 0


def test_040():
    """
    Commit message format - LLD | Auto | workflow_type="lld", issue=162 |
    Formatted message | Message includes title and "Ref #N" footer (NOT Closes)
    """
    # TDD: Arrange
    # (no setup needed)

    # TDD: Act
    message = format_commit_message("lld", issue_number=162)

    # TDD: Assert - message includes "Ref #N" (NOT "Closes" - LLD is design only)
    assert message == "docs: add LLD-162 via requirements workflow\n\nRef #162"


def test_050():
    """
    Commit message format - issue | Auto | workflow_type="issue",
    slug="my-feature" | Formatted message | Message matches `docs: add
    lineage for my-feature via requirements workflow`
    """
    # TDD: Arrange
    # (no setup needed)

    # TDD: Act
    message = format_commit_message("issue", slug="my-feature")

    # TDD: Assert
    assert message == "docs: add lineage for my-feature via requirements workflow"


def test_060(tmp_path):
    """
    Commit failure | Auto | Invalid repo state | GitOperationError raised |
    Error message contains "commit failed"
    """
    # TDD: Arrange
    created_files = ["docs/lld/active/LLD-162.md"]
    
    with patch("subprocess.run") as mock_run:
        mock_run.side_effect = [
            Mock(returncode=0, stdout="", stderr=""),  # git add succeeds
            Mock(returncode=1, stdout="", stderr="fatal: not a git repository"),  # git commit fails
        ]
        
        # TDD: Act & Assert
        with pytest.raises(GitOperationError) as exc_info:
            commit_and_push(
                created_files=created_files,
                workflow_type="lld",
                target_repo=tmp_path,
                issue_number=162,
            )
        
        assert "Failed to commit" in str(exc_info.value)


def test_070(tmp_path):
    """
    Push failure | Auto | Mock network error | GitOperationError raised |
    Error message contains "push failed"; local commit SHA in message
    """
    # TDD: Arrange
    created_files = ["docs/lld/active/LLD-162.md"]
    
    with patch("subprocess.run") as mock_run:
        mock_run.side_effect = [
            Mock(returncode=0, stdout="", stderr=""),  # git add
            Mock(returncode=0, stdout="[main abc123] message\n", stderr=""),  # git commit
            Mock(returncode=1, stdout="", stderr="fatal: unable to access 'https://...': Could not resolve host"),  # git push fails
        ]
        
        # TDD: Act & Assert
        with pytest.raises(GitOperationError) as exc_info:
            commit_and_push(
                created_files=created_files,
                workflow_type="lld",
                target_repo=tmp_path,
                issue_number=162,
            )
        
        error_msg = str(exc_info.value)
        assert "Failed to push" in error_msg
        assert "abc123" in error_msg  # Local commit SHA included


def test_080(tmp_path):
    """
    Selective staging | Auto | created_files + untracked file | Only
    created_files staged | Untracked file not in commit
    """
    # TDD: Arrange
    created_files = ["docs/lld/active/LLD-162.md"]
    # Simulate: there's also an untracked file "other.txt" in the repo
    # We verify that only the files in created_files are staged
    
    with patch("subprocess.run") as mock_run:
        mock_run.side_effect = [
            Mock(returncode=0, stdout="", stderr=""),  # git add (only our file)
            Mock(returncode=0, stdout="[main abc123] message\n", stderr=""),  # git commit
            Mock(returncode=0, stdout="", stderr=""),  # git push
        ]
        
        # TDD: Act
        commit_and_push(
            created_files=created_files,
            workflow_type="lld",
            target_repo=tmp_path,
            issue_number=162,
        )
        
        # TDD: Assert
        # Verify only the specified file was added (not other.txt)
        git_add_calls = [c for c in mock_run.call_args_list if c[0][0][1] == "add"]
        assert len(git_add_calls) == 1
        assert git_add_calls[0][0][0] == ["git", "add", "docs/lld/active/LLD-162.md"]


# Integration Tests
# -----------------

def test_090(tmp_path):
    """
    Integration: LLD then implement | Auto-Live | Full workflow sequence
    | Implementation finds LLD | Worktree contains LLD file
    """
    # TDD: Arrange
    # Create a bare remote repo for push target
    remote_path = tmp_path / "remote.git"
    remote_path.mkdir()
    subprocess.run(["git", "init", "--bare"], cwd=str(remote_path), check=True, capture_output=True)

    # Create a minimal git repo
    work_path = tmp_path / "work"
    work_path.mkdir()
    subprocess.run(["git", "init"], cwd=str(work_path), check=True, capture_output=True)
    subprocess.run(["git", "config", "user.email", "test@example.com"], cwd=str(work_path), check=True, capture_output=True)
    subprocess.run(["git", "config", "user.name", "Test User"], cwd=str(work_path), check=True, capture_output=True)
    subprocess.run(["git", "remote", "add", "origin", str(remote_path)], cwd=str(work_path), check=True, capture_output=True)
    
    # Create directory structure
    lld_dir = work_path / "docs" / "lld" / "active"
    lld_dir.mkdir(parents=True)

    lineage_dir = work_path / "docs" / "lineage" / "active" / "162-lld"
    lineage_dir.mkdir(parents=True)

    # Create LLD file
    lld_file = lld_dir / "LLD-162.md"
    lld_file.write_text("# LLD-162\n\nTest LLD content")

    # Create status file
    status_file = work_path / "docs" / "lld" / "lld-status.json"
    status_file.write_text('{"version": "1.0", "last_updated": "2024-01-01T00:00:00Z", "issues": {}}')

    # Create audit final file
    final_file = lineage_dir / "001-final.md"
    final_file.write_text("# LLD Finalized\n\nFinal content")

    # Initial commit and push to set up tracking
    subprocess.run(["git", "add", "."], cwd=str(work_path), check=True, capture_output=True)
    subprocess.run(["git", "commit", "-m", "Initial"], cwd=str(work_path), check=True, capture_output=True)
    # Get the current branch name (could be main or master depending on git config)
    branch_result = subprocess.run(["git", "branch", "--show-current"], cwd=str(work_path), capture_output=True, text=True)
    current_branch = branch_result.stdout.strip()
    subprocess.run(["git", "push", "-u", "origin", current_branch], cwd=str(work_path), check=True, capture_output=True)

    # Now modify the files to simulate the workflow creating new content
    lld_file.write_text("# LLD-162\n\nUpdated LLD content after workflow")
    status_file.write_text('{"version": "1.0", "last_updated": "2024-01-02T00:00:00Z", "issues": {"162": "APPROVED"}}')
    final_file.write_text("# LLD Finalized\n\nUpdated final content")

    # Create state
    state = create_initial_state(
        workflow_type="lld",
        assemblyzero_root=str(work_path),
        target_repo=str(work_path),
        issue_number=162,
    )
    state["audit_dir"] = str(lineage_dir)
    state["current_draft"] = "# LLD-162\n\nTest content"
    state["lld_status"] = "APPROVED"
    state["created_files"] = [
        "docs/lld/active/LLD-162.md",
        "docs/lld/lld-status.json",
        "docs/lineage/active/162-lld/001-final.md",
    ]

    # TDD: Act
    # Call the internal function that does commit/push
    # This will actually commit and push (to local bare remote)
    try:
        updated_state = _commit_and_push_files(state)
        commit_error = updated_state.get("commit_error", "")
        if commit_error:
            print(f"Commit error: {commit_error}")
        # Success = no error message (empty string is OK, means no error)
        commit_succeeded = not commit_error
    except Exception as e:
        print(f"Exception: {e}")
        commit_succeeded = False
        updated_state = {"commit_error": str(e)}

    # TDD: Assert
    assert commit_succeeded, f"Commit failed. State: {updated_state.get('commit_error', 'no error in state')}"

    # Verify commit exists
    log_result = subprocess.run(
        ["git", "log", "--oneline"],
        cwd=str(work_path),
        capture_output=True,
        text=True,
    )
    assert "docs: add LLD-162 via requirements workflow" in log_result.stdout

    # Verify files are in git
    ls_result = subprocess.run(
        ["git", "ls-files"],
        cwd=str(work_path),
        capture_output=True,
        text=True,
    )
    assert "docs/lld/active/LLD-162.md" in ls_result.stdout


# Issue #238 - Ref instead of Closes
# -----------------------------------

def test_format_commit_message_lld_uses_ref_not_closes():
    """LLD commits should reference issues, not close them."""
    message = format_commit_message("lld", issue_number=173)

    assert "Ref #173" in message, "Should use 'Ref' to reference issue"
    assert "Closes #173" not in message, "Should NOT close issue - LLD is design only"
    assert "closes #173" not in message.lower(), "Case-insensitive check"


def test_format_commit_message_issue_uses_ref_not_closes():
    """Issue brief commits should reference issues, not close them."""
    message = format_commit_message("issue", issue_number=99, slug="my-feature")

    assert "Closes #" not in message, "Issue workflow should not close issues"