"""Markdown templates for Innovation Briefs.

Provides structured templates for generating consistent output documents.
"""

from datetime import datetime


def generate_innovation_brief(
    topic: str,
    repos: list[dict],
    gap_analysis: str,
    executive_summary: str | None = None,
) -> str:
    """Generate a complete Innovation Brief document.

    Args:
        topic: Research topic.
        repos: List of analyzed repositories.
        gap_analysis: Gap analysis content.
        executive_summary: Optional executive summary.

    Returns:
        Formatted markdown document.
    """
    date = datetime.now().strftime("%Y-%m-%d")

    brief = f"""# Innovation Brief: {topic}

**Generated:** {date}
**Repositories Analyzed:** {len(repos)}

---

## Executive Summary

{executive_summary or _generate_default_summary(repos, gap_analysis)}

## Repositories Analyzed

"""

    if repos:
        brief += "| Repository | Stars | License | Description |\n"
        brief += "|------------|-------|---------|-------------|\n"
        for repo in repos:
            name = repo.get("name", "unknown")
            url = repo.get("url", "#")
            stars = repo.get("stars", 0)
            license_type = repo.get("license_type", "Unknown")
            desc = repo.get("description", "")[:50]
            brief += f"| [{name}]({url}) | â­ {stars} | {license_type} | {desc} |\n"
    else:
        brief += "*No repositories analyzed.*\n"

    brief += f"""

## Gap Analysis

{gap_analysis or "No analysis available."}

## Recommendations

Based on the analysis above, consider:

1. **Immediate Actions** - Quick wins that can be implemented now
2. **Medium-term Improvements** - Features requiring design work
3. **Long-term Strategic** - Architectural changes for future consideration

---

*Generated by AssemblyZero Scout Workflow*
"""

    return brief


def _generate_default_summary(repos: list[dict], gap_analysis: str) -> str:
    """Generate a default summary when none is provided.

    Args:
        repos: List of analyzed repositories.
        gap_analysis: Gap analysis content.

    Returns:
        Default summary text.
    """
    if not repos:
        return "No external repositories were analyzed. Consider adjusting search parameters."

    top_repo = max(repos, key=lambda r: r.get("stars", 0))
    licenses = set(r.get("license_type", "Unknown") for r in repos)

    summary = f"Analyzed {len(repos)} top repositories in this space. "
    summary += f"The most popular is [{top_repo.get('name')}]({top_repo.get('url')}) "
    summary += f"with {top_repo.get('stars', 0):,} stars. "

    if len(licenses) == 1:
        summary += f"All repositories use {list(licenses)[0]} license. "
    else:
        summary += f"Licenses include: {', '.join(sorted(licenses))}. "

    if gap_analysis:
        summary += "See Gap Analysis section for detailed findings."

    return summary


def generate_json_output(
    topic: str,
    repos: list[dict],
    gap_analysis: str,
) -> dict:
    """Generate JSON-formatted output for machine consumption.

    Args:
        topic: Research topic.
        repos: List of analyzed repositories.
        gap_analysis: Gap analysis content.

    Returns:
        Structured dictionary for JSON serialization.
    """
    return {
        "topic": topic,
        "generated_at": datetime.now().isoformat(),
        "repository_count": len(repos),
        "repositories": [
            {
                "name": r.get("name"),
                "url": r.get("url"),
                "stars": r.get("stars"),
                "license": r.get("license_type"),
                "description": r.get("description"),
            }
            for r in repos
        ],
        "gap_analysis": gap_analysis,
    }
