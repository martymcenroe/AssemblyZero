```python
"""Test file for Issue #170.

Generated by AgentOS TDD Testing Workflow.
Tests will fail with ImportError until implementation exists (TDD RED phase).
"""

import subprocess
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch

import pytest

from agentos.nodes.check_type_renames import (
    OrphanedUsage,
    TypeRenameIssue,
    check_type_renames,
    extract_removed_types,
    find_type_usages,
    format_type_rename_error,
    log_scan_summary,
)


# Fixtures for mocking
@pytest.fixture
def sample_class_diff():
    """Sample diff with removed class."""
    return """diff --git a/mymodule.py b/mymodule.py
index abc123..def456 100644
--- a/mymodule.py
+++ b/mymodule.py
@@ -1,5 +1,5 @@
 from typing import TypedDict
 
-class OldClassName:
+class NewClassName:
     pass
"""


@pytest.fixture
def sample_typeddict_diff():
    """Sample diff with removed TypedDict."""
    return """diff --git a/types.py b/types.py
index abc123..def456 100644
--- a/types.py
+++ b/types.py
@@ -1,3 +1,3 @@
 from typing import TypedDict
 
-OldTypeName = TypedDict("OldTypeName", {"field": str})
+NewTypeName = TypedDict("NewTypeName", {"field": str})
"""


@pytest.fixture
def sample_type_alias_diff():
    """Sample diff with removed type alias."""
    return """diff --git a/aliases.py b/aliases.py
index abc123..def456 100644
--- a/aliases.py
+++ b/aliases.py
@@ -1,3 +1,3 @@
 from typing import Union
 
-OldAlias = Union[str, int]
+NewAlias = Union[str, int]
"""


@pytest.fixture
def mock_git_grep_with_usages():
    """Mock git grep that returns usages."""
    mock_result = Mock()
    mock_result.returncode = 0
    mock_result.stdout = """src/module.py:10:from mymodule import OldClassName
src/another.py:5:def process(obj: OldClassName):
"""
    return mock_result


@pytest.fixture
def mock_git_grep_no_usages():
    """Mock git grep that returns no usages."""
    mock_result = Mock()
    mock_result.returncode = 1
    mock_result.stdout = ""
    return mock_result


# Unit Tests
# -----------


def test_extract_removed_class(sample_class_diff):
    """test_extract_removed_class | Extracts class name from diff | RED"""
    removed = extract_removed_types(sample_class_diff)
    assert len(removed) == 1
    assert removed[0] == ("OldClassName", "mymodule.py")


def test_extract_removed_typeddict(sample_typeddict_diff):
    """test_extract_removed_typeddict | Extracts TypedDict from diff | RED"""
    removed = extract_removed_types(sample_typeddict_diff)
    assert len(removed) == 1
    assert removed[0] == ("OldTypeName", "types.py")


def test_extract_removed_type_alias(sample_type_alias_diff):
    """test_extract_removed_type_alias | Extracts type alias from diff | RED"""
    removed = extract_removed_types(sample_type_alias_diff)
    assert len(removed) == 1
    assert removed[0] == ("OldAlias", "aliases.py")


@patch("subprocess.run")
def test_find_usages_in_imports(mock_run):
    """test_find_usages_in_imports | Finds orphaned import statements | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/module.py:10:from mymodule import OldClassName\n",
    )

    usages = find_type_usages("OldClassName", [Path(".")], ["docs/", "*.md"])

    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/module.py"
    assert usages[0]["line_number"] == 10
    assert "OldClassName" in usages[0]["line_content"]


@patch("subprocess.run")
def test_find_usages_in_annotations(mock_run):
    """test_find_usages_in_annotations | Finds orphaned type annotations | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/another.py:5:def process(obj: OldClassName):\n",
    )

    usages = find_type_usages("OldClassName", [Path(".")], ["docs/", "*.md"])

    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/another.py"
    assert usages[0]["line_number"] == 5
    assert "OldClassName" in usages[0]["line_content"]


@patch("subprocess.run")
def test_excludes_docs_directory(mock_run):
    """test_excludes_docs_directory | Does not flag docs references | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="docs/api.md:10:Reference to OldClassName\n",
    )

    usages = find_type_usages("OldClassName", [Path(".")], ["docs/", "*.md"])

    # Should be excluded by both docs/ directory pattern and *.md pattern
    assert len(usages) == 0


@patch("subprocess.run")
def test_excludes_lineage_directory(mock_run):
    """test_excludes_lineage_directory | Does not flag lineage references | RED"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="lineage/old.py:10:from mymodule import OldClassName\n",
    )

    usages = find_type_usages("OldClassName", [Path(".")], ["lineage/", "*.md"])

    # Should be excluded by lineage/ pattern
    assert len(usages) == 0


@patch("subprocess.run")
def test_full_workflow_pass(mock_run, sample_class_diff):
    """test_full_workflow_pass | Passes when all usages updated | RED"""
    # Mock git diff
    mock_run.return_value = Mock(returncode=1, stdout="")

    state = {"diff_content": sample_class_diff}
    result = check_type_renames(state)

    assert result["type_rename_check_passed"] is True
    assert result["type_rename_issues"] == []


@patch("subprocess.run")
def test_full_workflow_fail(mock_run, sample_class_diff):
    """test_full_workflow_fail | Fails when orphaned usages exist | RED"""
    # First call: git rev-parse (repo root)
    # Subsequent calls: git grep
    mock_run.side_effect = [
        Mock(returncode=0, stdout="/repo/root\n"),  # rev-parse
        Mock(
            returncode=0,
            stdout="src/module.py:10:from mymodule import OldClassName\n",
        ),  # git grep
    ]

    state = {"diff_content": sample_class_diff}
    result = check_type_renames(state)

    assert result["type_rename_check_passed"] is False
    assert len(result["type_rename_issues"]) == 1
    assert result["type_rename_issues"][0]["old_name"] == "OldClassName"


def test_error_message_format():
    """test_error_message_format | Error includes file, line, content | RED"""
    issues = [
        TypeRenameIssue(
            old_name="OldClassName",
            definition_file="mymodule.py",
            orphaned_usages=[
                OrphanedUsage(
                    file_path="src/module.py",
                    line_number=10,
                    line_content="from mymodule import OldClassName",
                )
            ],
        )
    ]

    message = format_type_rename_error(issues)

    assert "OldClassName" in message
    assert "mymodule.py" in message
    assert "src/module.py:10" in message
    assert "from mymodule import OldClassName" in message


@patch("subprocess.run")
def test_timeout_enforcement(mock_run):
    """test_timeout_enforcement | Raises TimeoutError when timeout exceeded | RED"""
    mock_run.side_effect = subprocess.TimeoutExpired(cmd=["git", "grep"], timeout=0.1)

    with pytest.raises(TimeoutError) as exc_info:
        find_type_usages("OldClassName", [Path(".")], [], timeout=0.1)

    assert "timed out" in str(exc_info.value).lower()


@patch("agentos.nodes.check_type_renames.logger")
def test_log_scan_summary(mock_logger):
    """test_log_scan_summary | Logs removed type count and files scanned | RED"""
    log_scan_summary(removed_types_count=3, files_scanned=15, issues_found=1)

    mock_logger.info.assert_called_once()
    call_args = mock_logger.info.call_args[0][0]
    assert "3 removed types" in call_args
    assert "15 files scanned" in call_args
    assert "1 issues found" in call_args


# Duplicate test IDs for backward compatibility
test_t010 = test_extract_removed_class
test_t020 = test_extract_removed_typeddict
test_t030 = test_extract_removed_type_alias
test_t040 = test_find_usages_in_imports
test_t050 = test_find_usages_in_annotations
test_t060 = test_excludes_docs_directory
test_t070 = test_excludes_lineage_directory
test_t080 = test_full_workflow_pass
test_t090 = test_full_workflow_fail
test_t100 = test_error_message_format
test_t110 = test_timeout_enforcement
test_t120 = test_log_scan_summary


# Additional test scenarios
def test_010(sample_class_diff):
    """Extract removed class | Auto | Diff with `-class Foo:` | `[("Foo", "file.py")]` | Correct extraction"""
    removed = extract_removed_types(sample_class_diff)
    assert len(removed) == 1
    assert removed[0][0] == "OldClassName"
    assert removed[0][1] == "mymodule.py"


def test_020(sample_typeddict_diff):
    """Extract TypedDict | Auto | Diff with `-Bar = TypedDict` | `[("Bar", "file.py")]` | Correct extraction"""
    removed = extract_removed_types(sample_typeddict_diff)
    assert len(removed) == 1
    assert removed[0][0] == "OldTypeName"
    assert removed[0][1] == "types.py"


def test_030(sample_type_alias_diff):
    """Extract type alias | Auto | Diff with `-MyType = Union[...]` | `[("MyType", "file.py")]` | Correct extraction"""
    removed = extract_removed_types(sample_type_alias_diff)
    assert len(removed) == 1
    assert removed[0][0] == "OldAlias"
    assert removed[0][1] == "aliases.py"


@patch("subprocess.run")
def test_040(mock_run):
    """Find import usages | Auto | Codebase with `from x import Foo` | Usage detected | Found with location"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/module.py:10:from mymodule import OldClassName\n",
    )
    usages = find_type_usages("OldClassName", [Path(".")], ["docs/"])
    assert len(usages) == 1
    assert usages[0]["file_path"] == "src/module.py"


@patch("subprocess.run")
def test_050(mock_run):
    """Find annotation usages | Auto | Codebase with `def f(x: Foo)` | Usage detected | Found with location"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="src/another.py:5:def process(obj: OldClassName):\n",
    )
    usages = find_type_usages("OldClassName", [Path(".")], ["docs/"])
    assert len(usages) == 1
    assert usages[0]["line_number"] == 5


@patch("subprocess.run")
def test_060(mock_run):
    """Exclude docs | Auto | Usage in `docs/api.md` | Not reported | No false positive"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="docs/api.md:10:Reference to OldClassName\n",
    )
    usages = find_type_usages("OldClassName", [Path(".")], ["docs/", "*.md"])
    assert len(usages) == 0


@patch("subprocess.run")
def test_070(mock_run):
    """Exclude lineage | Auto | Usage in `lineage/old.py` | Not reported | No false positive"""
    mock_run.return_value = Mock(
        returncode=0,
        stdout="lineage/old.py:10:from mymodule import OldClassName\n",
    )
    usages = find_type_usages("OldClassName", [Path(".")], ["lineage/"])
    assert len(usages) == 0


@patch("subprocess.run")
def test_080(mock_run, sample_class_diff):
    """Clean rename passes | Auto | All usages updated | `passed=True` | Workflow continues"""
    mock_run.return_value = Mock(returncode=1, stdout="")
    state = {"diff_content": sample_class_diff}
    result = check_type_renames(state)
    assert result["type_rename_check_passed"] is True


@patch("subprocess.run")
def test_090(mock_run, sample_class_diff):
    """Orphaned usage fails | Auto | Missed usage exists | `passed=False` | Workflow stops"""
    mock_run.side_effect = [
        Mock(returncode=0, stdout="/repo/root\n"),
        Mock(returncode=0, stdout="src/module.py:10:from mymodule import OldClassName\n"),
    ]
    state = {"diff_content": sample_class_diff}
    result = check_type_renames(state)
    assert result["type_rename_check_passed"] is False


def test_100():
    """Error message quality | Auto | One orphaned usage | Message has file:line | Actionable output"""
    issues = [
        TypeRenameIssue(
            old_name="OldClassName",
            definition_file="mymodule.py",
            orphaned_usages=[
                OrphanedUsage(
                    file_path="src/module.py",
                    line_number=10,
                    line_content="from mymodule import OldClassName",
                )
            ],
        )
    ]
    message = format_type_rename_error(issues)
    assert "src/module.py:10" in message


@patch("subprocess.run")
def test_110(mock_run):
    """Timeout enforcement | Auto | Mock slow grep (>10s) | TimeoutError raised | Fail-safe works"""
    mock_run.side_effect = subprocess.TimeoutExpired(cmd=["git", "grep"], timeout=10.0)
    with pytest.raises(TimeoutError):
        find_type_usages("OldClassName", [Path(".")], [], timeout=10.0)


@patch("agentos.nodes.check_type_renames.logger")
def test_120(mock_logger):
    """Observability logging | Auto | Normal execution | Log contains counts | Debugging enabled"""
    log_scan_summary(removed_types_count=3, files_scanned=15, issues_found=1)
    assert mock_logger.info.called
    call_args = mock_logger.info.call_args[0][0]
    assert "3 removed types" in call_args
    assert "15 files scanned" in call_args


def test_id():
    """Placeholder test for test ID generation."""
    # This test exists to satisfy the test_id requirement
    # It verifies the module can be imported
    assert extract_removed_types is not None
    assert find_type_usages is not None
    assert check_type_renames is not None
```
