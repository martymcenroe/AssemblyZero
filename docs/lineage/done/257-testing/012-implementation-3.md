# File: tests/test_issue_257.py

```python
"""Test file for Issue #257.

Generated by AgentOS TDD Testing Workflow.
Tests for verdict parsing and draft updating functionality.
"""

import logging
import pytest

from agentos.workflows.requirements.parsers.verdict_parser import (
    ResolvedQuestion,
    Tier3Suggestion,
    VerdictParseResult,
    parse_verdict,
)
from agentos.workflows.requirements.parsers.draft_updater import (
    update_draft,
    update_draft_with_resolutions,
    update_draft_with_suggestions,
)


# Test Fixtures
# -------------

@pytest.fixture
def sample_approved_verdict_with_resolutions():
    """Sample APPROVED verdict with resolved open questions."""
    return """
## Verdict

- [x] **APPROVED**
- [ ] REVISE
- [ ] DISCUSS

## Open Questions Resolved

- [x] ~~Should we use strikethrough for original text?~~ **RESOLVED:** Yes, use strikethrough for the original question text and append the resolution.
- [x] ~~Where should Tier 3 suggestions go?~~ **RESOLVED:** Add them to a new "Reviewer Suggestions" section at the end of the draft.

## Tier 3

- Consider adding a backup mechanism before modifying drafts [Section 2.1]
- The idempotency tests could be more comprehensive (low priority)
"""


@pytest.fixture
def sample_approved_verdict_simple():
    """Simple APPROVED verdict without resolutions."""
    return """
## Verdict

VERDICT: APPROVED

No open questions to resolve.
"""


@pytest.fixture
def sample_rejected_verdict():
    """Sample REJECTED/BLOCKED verdict."""
    return """
## Verdict

- [ ] APPROVED
- [x] **REVISE**
- [ ] DISCUSS

## Blocking Issues

1. Missing error handling in the parser
2. No tests for edge cases
"""


@pytest.fixture
def sample_draft_with_open_questions():
    """Sample draft LLD with open questions."""
    return """# LLD-257: Draft Update Feature

## 1. Context & Goal

This feature updates drafts with resolved questions.

### Open Questions

- [ ] Should we use strikethrough for original text?
- [ ] Where should Tier 3 suggestions go?
- [ ] Should we create a backup before modification?

## 2. Proposed Changes

Changes will be made to the review and finalize nodes.

## 3. Test Plan

- Unit tests for parser
- Integration tests for workflow
"""


@pytest.fixture
def sample_draft_no_open_questions():
    """Sample draft with no open questions."""
    return """# LLD-257: Draft Update Feature

## 1. Context & Goal

This feature updates drafts with resolved questions.

### Open Questions

*None at this time.*

## 2. Proposed Changes

Changes will be made to the review and finalize nodes.
"""


@pytest.fixture
def test_client():
    """Test client for API calls."""
    yield None


# Unit Tests
# -----------

def test_id():
    """
    Basic sanity test for imports.
    """
    # Verify imports work
    assert VerdictParseResult is not None
    assert ResolvedQuestion is not None
    assert Tier3Suggestion is not None
    assert parse_verdict is not None


def test_t010(sample_approved_verdict_with_resolutions):
    """
    Parse APPROVED verdict with resolved questions | Returns
    VerdictParseResult with resolutions | RED
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert result.verdict_status == "APPROVED"
    assert len(result.resolutions) >= 2
    assert any("strikethrough" in r.question_text.lower() for r in result.resolutions)
    assert any("Tier 3" in r.question_text for r in result.resolutions)


def test_t020(sample_approved_verdict_with_resolutions):
    """
    Parse APPROVED verdict with Tier 3 suggestions | Returns
    VerdictParseResult with suggestions | RED
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert result.verdict_status == "APPROVED"
    assert len(result.suggestions) >= 1
    assert any("backup" in s.suggestion_text.lower() for s in result.suggestions)


def test_t030(sample_rejected_verdict):
    """
    Parse REJECTED verdict | Returns VerdictParseResult with empty
    resolutions | RED
    """
    # TDD: Arrange
    verdict = sample_rejected_verdict

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert result.verdict_status == "BLOCKED"
    assert len(result.resolutions) == 0


def test_t040(sample_draft_with_open_questions):
    """
    Update draft open questions with resolutions | Checkboxes changed to
    `- [x]` with resolution text | RED
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    resolutions = [
        ResolvedQuestion(
            question_text="Should we use strikethrough for original text?",
            resolution_text="Yes, use strikethrough.",
            original_line="- [ ] Should we use strikethrough for original text?",
        )
    ]

    # TDD: Act
    updated_draft, warnings = update_draft_with_resolutions(draft, resolutions)

    # TDD: Assert
    assert "- [x]" in updated_draft
    assert "**RESOLVED:**" in updated_draft
    assert "Yes, use strikethrough" in updated_draft


def test_t050(sample_draft_with_open_questions):
    """
    Update draft with suggestions (new section) | Reviewer Suggestions
    section appended | RED
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    suggestions = [
        Tier3Suggestion(
            suggestion_text="Consider adding a backup mechanism",
            section="Section 2.1",
            priority="",
        )
    ]

    # TDD: Act
    updated_draft, warnings = update_draft_with_suggestions(draft, suggestions)

    # TDD: Assert
    assert "## Reviewer Suggestions" in updated_draft
    assert "backup mechanism" in updated_draft
    assert "Tier 3 suggestions" in updated_draft


def test_t060(sample_draft_with_open_questions, caplog):
    """
    Handle missing open question in draft | Log warning, continue
    processing | RED
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    resolutions = [
        ResolvedQuestion(
            question_text="This question does not exist in the draft",
            resolution_text="Some resolution",
            original_line="- [ ] This question does not exist",
        )
    ]

    # TDD: Act
    with caplog.at_level(logging.WARNING):
        updated_draft, warnings = update_draft_with_resolutions(draft, resolutions)

    # TDD: Assert
    assert len(warnings) > 0
    assert "not found" in warnings[0].lower()
    # Draft should be unchanged except for the warning
    assert updated_draft == draft


def test_t090(sample_draft_with_open_questions):
    """
    Idempotency: same verdict applied twice | Same result both times |
    RED
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    resolutions = [
        ResolvedQuestion(
            question_text="Should we use strikethrough for original text?",
            resolution_text="Yes, use strikethrough.",
            original_line="- [ ] Should we use strikethrough for original text?",
        )
    ]

    # TDD: Act
    updated_draft1, _ = update_draft_with_resolutions(draft, resolutions)
    updated_draft2, _ = update_draft_with_resolutions(updated_draft1, resolutions)

    # TDD: Assert
    # Second application should produce the same result
    assert updated_draft1 == updated_draft2
    # Should only have one RESOLVED marker
    assert updated_draft1.count("**RESOLVED:**") == 1


def test_010(sample_approved_verdict_with_resolutions):
    """
    Parse approved verdict with resolutions | Auto | Verdict with "Open
    Questions: RESOLVED" | List of ResolvedQuestion | Correct questions
    and resolution text extracted
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert result.verdict_status == "APPROVED"
    assert len(result.resolutions) >= 2
    # Check that resolution text was captured
    for res in result.resolutions:
        assert res.resolution_text, f"Resolution should have text: {res.question_text}"


def test_020(sample_approved_verdict_with_resolutions):
    """
    Parse approved verdict with suggestions | Auto | Verdict with "Tier
    3" section | List of Tier3Suggestion | All suggestions captured
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert len(result.suggestions) >= 2
    # Check suggestion properties
    for suggestion in result.suggestions:
        assert suggestion.suggestion_text


def test_030(sample_rejected_verdict):
    """
    Parse rejected verdict | Auto | REJECTED verdict | Empty resolutions
    list | No resolutions extracted
    """
    # TDD: Arrange
    verdict = sample_rejected_verdict

    # TDD: Act
    result = parse_verdict(verdict)

    # TDD: Assert
    assert result.verdict_status == "BLOCKED"
    assert result.resolutions == []
    assert result.suggestions == []


def test_040(sample_draft_with_open_questions):
    """
    Update draft checkboxes | Auto | Draft + resolutions | Updated draft
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    resolutions = [
        ResolvedQuestion(
            question_text="Should we use strikethrough for original text",
            resolution_text="Yes",
            original_line="",
        )
    ]

    # TDD: Act
    updated, warnings = update_draft_with_resolutions(draft, resolutions)

    # TDD: Assert
    # Original unchecked box should be replaced
    assert "- [ ] Should we use strikethrough" not in updated
    assert "- [x]" in updated


def test_050(sample_draft_with_open_questions):
    """
    Add suggestions section | Auto | Draft + suggestions | Updated draft
    | New section at end
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    suggestions = [
        Tier3Suggestion(suggestion_text="Add more tests", section="", priority="low")
    ]

    # TDD: Act
    updated, warnings = update_draft_with_suggestions(draft, suggestions)

    # TDD: Assert
    assert "## Reviewer Suggestions" in updated
    assert "Add more tests" in updated
    # Section should be near the end
    suggestions_pos = updated.find("## Reviewer Suggestions")
    assert suggestions_pos > len(updated) // 2


def test_060(sample_draft_with_open_questions, caplog):
    """
    Missing question in draft | Auto | Resolution for non-existent
    question | Warning logged, draft unchanged | No error thrown
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    resolutions = [
        ResolvedQuestion(
            question_text="Nonexistent question that was never in the draft",
            resolution_text="Some answer",
            original_line="",
        )
    ]

    # TDD: Act - should not raise
    updated, warnings = update_draft_with_resolutions(draft, resolutions)

    # TDD: Assert
    assert len(warnings) > 0
    assert draft == updated  # Unchanged


def test_090(sample_draft_with_open_questions):
    """
    Idempotent update | Auto | Apply same verdict twice | Same draft | No
    duplicate markers
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    suggestions = [
        Tier3Suggestion(suggestion_text="Consider caching", section="", priority="")
    ]

    # TDD: Act
    updated1, _ = update_draft_with_suggestions(draft, suggestions)
    updated2, _ = update_draft_with_suggestions(updated1, suggestions)

    # TDD: Assert
    assert updated1 == updated2
    assert updated1.count("## Reviewer Suggestions") == 1


def test_100(sample_draft_no_open_questions):
    """
    Empty Open Questions section | Auto | Verdict resolves nothing |
    Unchanged draft | No modifications
    """
    # TDD: Arrange
    draft = sample_draft_no_open_questions
    resolutions = []  # No resolutions

    # TDD: Act
    updated, warnings = update_draft_with_resolutions(draft, resolutions)

    # TDD: Assert
    assert updated == draft


def test_110():
    """
    Malformed verdict | Auto | Verdict missing expected sections |
    Warning, original draft | Graceful degradation
    """
    # TDD: Arrange
    malformed_verdict = "Just some random text without proper structure"

    # TDD: Act - should not raise
    result = parse_verdict(malformed_verdict)

    # TDD: Assert
    assert result.verdict_status == "BLOCKED"  # Default to safe
    assert result.resolutions == []
    assert result.suggestions == []


# Integration Tests
# -----------------

@pytest.mark.integration
def test_070(
    test_client,
    sample_approved_verdict_with_resolutions,
    sample_draft_with_open_questions,
):
    """
    Review node integration | Auto | State with APPROVED verdict | State
    with updated_draft | Draft contains resolutions
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    verdict_result = parse_verdict(verdict)
    updated_draft, warnings = update_draft(draft, verdict_result)

    # TDD: Assert
    assert "- [x]" in updated_draft
    assert "**RESOLVED:**" in updated_draft
    # Should also have suggestions section
    assert "## Reviewer Suggestions" in updated_draft


@pytest.mark.integration
def test_080(
    test_client,
    sample_approved_verdict_with_resolutions,
    sample_draft_with_open_questions,
):
    """
    Finalize node integration | Auto | State with updated_draft | Final
    LLD | LLD contains `- [x]`
    """
    # TDD: Arrange
    draft = sample_draft_with_open_questions
    verdict = sample_approved_verdict_with_resolutions

    # TDD: Act
    verdict_result = parse_verdict(verdict)
    final_draft, _ = update_draft(draft, verdict_result)

    # TDD: Assert
    # Final draft should have resolved questions
    assert "- [x]" in final_draft
    # Should have at least one resolved question with resolution text
    assert "**RESOLVED:**" in final_draft


# E2E Tests
# ---------

@pytest.mark.e2e
def test_t070(test_client, sample_approved_verdict_with_resolutions, sample_draft_with_open_questions):
    """
    End-to-end: review node updates draft on approval | State contains
    updated_draft after approval | RED
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions
    draft = sample_draft_with_open_questions

    # TDD: Act - Full flow
    verdict_result = parse_verdict(verdict)
    assert verdict_result.verdict_status == "APPROVED"

    updated_draft, warnings = update_draft(draft, verdict_result)

    # TDD: Assert
    assert updated_draft != draft  # Draft was modified
    assert "- [x]" in updated_draft
    assert "**RESOLVED:**" in updated_draft


@pytest.mark.e2e
def test_t080(test_client, sample_approved_verdict_with_resolutions, sample_draft_with_open_questions):
    """
    End-to-end: finalize uses updated draft | Final LLD contains resolved
    questions | RED
    """
    # TDD: Arrange
    verdict = sample_approved_verdict_with_resolutions
    draft = sample_draft_with_open_questions

    # TDD: Act - Simulate full workflow
    verdict_result = parse_verdict(verdict)
    final_draft, _ = update_draft(draft, verdict_result)

    # TDD: Assert - Final LLD has all resolved content
    assert "- [x]" in final_draft
    # Original unchecked questions for resolved items should be gone
    # (except for the one not resolved: "Should we create a backup")
    resolved_questions = [r.question_text for r in verdict_result.resolutions]
    for q in resolved_questions:
        # The checked version should exist
        assert "- [x]" in final_draft
```