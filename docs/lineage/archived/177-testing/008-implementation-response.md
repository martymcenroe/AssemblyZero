Now I'll create the implementation. I need to:
1. Update the test file with proper test implementations
2. Create a unit test file `tests/test_lld_verification.py` if the LLD requires separate unit tests

Let me provide the complete updated test file that will pass all tests:

```python
# File: tests/test_issue_177.py

"""Test file for Issue #177.

Generated by AgentOS TDD Testing Workflow.
Tests for LLD verification gate that ensures LLDs were genuinely approved.
"""

import pytest
from pathlib import Path
import tempfile
import os

from agentos.utils.lld_verification import (
    LLDVerificationResult,
    LLDVerificationError,
    verify_lld_approval,
    run_verification_gate,
    has_gemini_approved_footer,
    extract_review_log_verdicts,
    detect_false_approval,
)


# Sample LLD content fixtures
@pytest.fixture
def lld_with_footer_approval():
    """LLD with genuine Gemini APPROVED footer."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-15 | REVISE | Minor issues |
| R2 | 2026-02-01 | APPROVED | None |

**Final Status:** APPROVED

<sub>**Gemini Review:** APPROVED | **Model:** gemini-3-pro-preview | **Date:** 2026-02-01</sub>
"""


@pytest.fixture
def lld_with_review_log_approval():
    """LLD with APPROVED in review log but no footer."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-15 | REVISE | Minor issues |
| R2 | 2026-02-01 | APPROVED | None |

**Final Status:** APPROVED
"""


@pytest.fixture
def lld_with_false_approval_revise():
    """LLD with APPROVED status but last review is REVISE (forgery)."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-15 | APPROVED | None |
| R2 | 2026-02-01 | REVISE | Needs work |

**Final Status:** APPROVED
"""


@pytest.fixture
def lld_with_false_approval_pending():
    """LLD with APPROVED status but last review is PENDING (forgery)."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-15 | PENDING | Awaiting review |

**Final Status:** APPROVED
"""


@pytest.fixture
def lld_with_no_approval():
    """LLD with no approval markers at all."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## 2. Proposed Changes

Changes go here.
"""


@pytest.fixture
def lld_with_multiple_reviews_last_approved():
    """LLD with multiple reviews, last is APPROVED."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-10 | REVISE | First pass |
| R2 | 2026-01-15 | REVISE | Still issues |
| R3 | 2026-02-01 | APPROVED | All fixed |

**Final Status:** APPROVED
"""


@pytest.fixture
def lld_with_multiple_reviews_last_revise():
    """LLD with multiple reviews, last is REVISE."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-15 | APPROVED | Initial |
| R2 | 2026-02-01 | REVISE | Found issues |

**Final Status:** REVISE
"""


@pytest.fixture
def lld_with_empty_review_log():
    """LLD with empty review log section."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Some context here.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|

**Final Status:** Awaiting review
"""


@pytest.fixture
def lld_with_approved_no_final_status():
    """LLD with Status APPROVED text but no proper Final Status line."""
    return """# 177 - Feature: LLD Verification Gate

## 1. Context & Goal

Status: APPROVED somewhere in text.

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
"""


# Integration/E2E fixtures
@pytest.fixture
def test_client():
    """Test client for API calls."""
    # For integration tests, we use a temp directory as project root
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


# Unit Tests
# -----------

def test_010(lld_with_footer_approval):
    """
    Genuine footer approval | Auto | LLD with `<sub>**Gemini Review:**
    APPROVED...` | is_valid=True, confidence="high" | Returns pass
    """
    # TDD: Arrange
    lld_content = lld_with_footer_approval

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is True
    assert result['confidence'] == "high"
    assert result['approval_source'] == "footer"


def test_020(lld_with_review_log_approval):
    """
    Review log approval (final) | Auto | LLD with `| APPROVED |` as
    last row | is_valid=True, confidence="medium" | Returns pass
    """
    # TDD: Arrange
    lld_content = lld_with_review_log_approval

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is True
    assert result['confidence'] == "medium"
    assert result['approval_source'] == "review_log"


def test_030(lld_with_false_approval_revise):
    """
    False approval - REVISE then APPROVED status | Auto | Review shows
    REVISE, status APPROVED | is_valid=False, error_type="forgery" |
    Returns fail with "FALSE APPROVAL"
    """
    # TDD: Arrange
    lld_content = lld_with_false_approval_revise

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    assert "FALSE APPROVAL" in result['reason']
    assert result['last_verdict'] == "REVISE"


def test_040(lld_with_false_approval_pending):
    """
    False approval - PENDING then APPROVED status | Auto | Review shows
    PENDING, status APPROVED | is_valid=False, error_type="forgery" |
    Returns fail with "FALSE APPROVAL"
    """
    # TDD: Arrange
    lld_content = lld_with_false_approval_pending

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    assert "FALSE APPROVAL" in result['reason']
    assert result['last_verdict'] == "PENDING"


def test_050(lld_with_no_approval):
    """
    No approval evidence | Auto | LLD with no approval markers |
    is_valid=False, error_type="not_approved" | Returns fail
    """
    # TDD: Arrange
    lld_content = lld_with_no_approval

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    assert result['approval_source'] is None


def test_060(lld_with_multiple_reviews_last_approved):
    """
    Multiple reviews, last is APPROVED | Auto | 3 reviews: REVISE,
    REVISE, APPROVED | is_valid=True | Returns pass
    """
    # TDD: Arrange
    lld_content = lld_with_multiple_reviews_last_approved

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is True
    assert result['last_verdict'] == "APPROVED"


def test_070(lld_with_multiple_reviews_last_revise):
    """
    Multiple reviews, last is REVISE | Auto | 3 reviews: APPROVED, REVISE
    | is_valid=False | Returns fail
    """
    # TDD: Arrange
    lld_content = lld_with_multiple_reviews_last_revise

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    assert result['last_verdict'] == "REVISE"


def test_080(lld_with_empty_review_log):
    """
    Empty review log | Auto | Review log section exists but empty |
    is_valid=False, error_type="not_approved" | Returns fail
    """
    # TDD: Arrange
    lld_content = lld_with_empty_review_log

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    assert result['approval_source'] is None


def test_110(test_client):
    """
    Path traversal attempt | Auto | Path outside project root | Raises
    exception before read | Security check blocks
    """
    # TDD: Arrange
    project_root = test_client
    # Try to access a path outside project root
    malicious_path = Path("/etc/passwd")

    # TDD: Act & Assert
    with pytest.raises(ValueError) as exc_info:
        run_verification_gate(malicious_path, project_root=project_root)

    assert "outside project root" in str(exc_info.value)


def test_120(lld_with_approved_no_final_status):
    """
    Status APPROVED but no Final Status line | Auto | LLD missing Final
    Status section | is_valid=False, error_type="not_approved" | Returns
    fail
    """
    # TDD: Arrange
    lld_content = lld_with_approved_no_final_status

    # TDD: Act
    result = verify_lld_approval(lld_content)

    # TDD: Assert
    assert result['is_valid'] is False
    # No Final Status line means no approval
    assert result['approval_source'] is None



# Integration Tests
# -----------------

def test_090(test_client):
    """
    Gate integration - pass | Auto | Valid LLD path | No exception raised
    | Workflow continues
    """
    # TDD: Arrange
    project_root = test_client
    lld_dir = project_root / "docs" / "LLDs" / "active"
    lld_dir.mkdir(parents=True)

    lld_content = """# 177 - Feature: Test

## Appendix

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-02-01 | APPROVED | None |

**Final Status:** APPROVED

<sub>**Gemini Review:** APPROVED | **Model:** gemini-3-pro-preview | **Date:** 2026-02-01</sub>
"""
    lld_path = lld_dir / "177-test.md"
    lld_path.write_text(lld_content, encoding='utf-8')

    # TDD: Act - should not raise
    run_verification_gate(lld_path, project_root=project_root)

    # TDD: Assert - if we get here, no exception was raised
    assert True


def test_100(test_client):
    """
    Gate integration - fail | Auto | Invalid LLD path |
    LLDVerificationError raised | Exception has suggestion
    """
    # TDD: Arrange
    project_root = test_client
    lld_dir = project_root / "docs" / "LLDs" / "active"
    lld_dir.mkdir(parents=True)

    # LLD with no approval
    lld_content = """# 177 - Feature: Test

## 1. Context

Not approved yet.
"""
    lld_path = lld_dir / "177-test.md"
    lld_path.write_text(lld_content, encoding='utf-8')

    # TDD: Act & Assert
    with pytest.raises(LLDVerificationError) as exc_info:
        run_verification_gate(lld_path, project_root=project_root)

    # Verify exception has helpful suggestion
    assert exc_info.value.suggestion is not None
    assert len(exc_info.value.suggestion) > 0
```

```python
# File: tests/test_lld_verification.py

"""Unit tests for LLD verification module.

These tests focus on the individual functions in the verification module.
"""

import pytest
from pathlib import Path
import tempfile

from agentos.utils.lld_verification import (
    LLDVerificationResult,
    LLDVerificationError,
    has_gemini_approved_footer,
    extract_review_log_verdicts,
    detect_false_approval,
    verify_lld_approval,
    run_verification_gate,
)


class TestHasGeminiApprovedFooter:
    """Tests for has_gemini_approved_footer function."""

    def test_footer_present(self):
        """Detects genuine APPROVED footer."""
        content = """# LLD

<sub>**Gemini Review:** APPROVED | **Model:** gemini-3-pro-preview</sub>
"""
        assert has_gemini_approved_footer(content) is True

    def test_footer_absent(self):
        """Returns False when no footer."""
        content = """# LLD

No footer here.
"""
        assert has_gemini_approved_footer(content) is False

    def test_footer_revise_not_approved(self):
        """REVISE footer is not an approval."""
        content = """# LLD

<sub>**Gemini Review:** REVISE | **Model:** gemini-3-pro-preview</sub>
"""
        assert has_gemini_approved_footer(content) is False


class TestExtractReviewLogVerdicts:
    """Tests for extract_review_log_verdicts function."""

    def test_extracts_multiple_verdicts(self):
        """Extracts all verdicts from review log table."""
        content = """# LLD

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-01-10 | REVISE | Issue 1 |
| R2 | 2026-01-15 | REVISE | Issue 2 |
| R3 | 2026-02-01 | APPROVED | None |

**Final Status:** APPROVED
"""
        verdicts = extract_review_log_verdicts(content)

        assert len(verdicts) == 3
        assert verdicts[0] == ("R1", "2026-01-10", "REVISE")
        assert verdicts[1] == ("R2", "2026-01-15", "REVISE")
        assert verdicts[2] == ("R3", "2026-02-01", "APPROVED")

    def test_no_review_summary_section(self):
        """Returns empty list when no Review Summary."""
        content = """# LLD

Just content, no review summary.
"""
        verdicts = extract_review_log_verdicts(content)
        assert verdicts == []

    def test_empty_table(self):
        """Returns empty list for empty table."""
        content = """# LLD

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|

**Final Status:** Pending
"""
        verdicts = extract_review_log_verdicts(content)
        assert verdicts == []


class TestDetectFalseApproval:
    """Tests for detect_false_approval function."""

    def test_no_false_approval_when_status_matches(self):
        """No false approval when status matches verdict."""
        content = """**Final Status:** APPROVED"""
        is_false, details = detect_false_approval(content, "APPROVED")
        assert is_false is False

    def test_detects_revise_with_approved_status(self):
        """Detects false approval: REVISE verdict but APPROVED status."""
        content = """**Final Status:** APPROVED"""
        is_false, details = detect_false_approval(content, "REVISE")
        assert is_false is True
        assert "REVISE" in details

    def test_detects_pending_with_approved_status(self):
        """Detects false approval: PENDING verdict but APPROVED status."""
        content = """**Final Status:** APPROVED"""
        is_false, details = detect_false_approval(content, "PENDING")
        assert is_false is True
        assert "PENDING" in details

    def test_no_false_approval_when_no_final_status(self):
        """No false approval if Final Status line is missing."""
        content = """Some content without Final Status"""
        is_false, details = detect_false_approval(content, "REVISE")
        assert is_false is False


class TestVerifyLldApproval:
    """Tests for verify_lld_approval function."""

    def test_high_confidence_footer(self):
        """Footer approval gives high confidence."""
        content = """<sub>**Gemini Review:** APPROVED | **Model:** gemini-3-pro</sub>"""
        result = verify_lld_approval(content)
        assert result['is_valid'] is True
        assert result['confidence'] == "high"
        assert result['approval_source'] == "footer"

    def test_medium_confidence_review_log(self):
        """Review log approval gives medium confidence."""
        content = """### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| R1 | 2026-02-01 | APPROVED | None |

**Final Status:** APPROVED
"""
        result = verify_lld_approval(content)
        assert result['is_valid'] is True
        assert result['confidence'] == "medium"
        assert result['approval_source'] == "review_log"

    def test_invalid_no_evidence(self):
        """No approval evidence results in invalid."""
        content = """# Just an LLD with no approval markers"""
        result = verify_lld_approval(content)
        assert result['is_valid'] is False


class TestRunVerificationGate:
    """Tests for run_verification_gate function."""

    def test_passes_for_approved_lld(self):
        """Gate passes silently for approved LLD."""
        with tempfile.TemporaryDirectory() as tmpdir:
            project_root = Path(tmpdir)
            lld_path = project_root / "test.md"
            lld_path.write_text(
                "<sub>**Gemini Review:** APPROVED | **Model:** gemini-3-pro</sub>",
                encoding='utf-8'
            )

            # Should not raise
            run_verification_gate(lld_path, project_root=project_root)

    def test_raises_for_unapproved_lld(self):
        """Gate raises LLDVerificationError for unapproved LLD."""
        with tempfile.TemporaryDirectory() as tmpdir:
            project_root = Path(tmpdir)
            lld_path = project_root / "test.md"
            lld_path.write_text("# Not approved", encoding='utf-8')

            with pytest.raises(LLDVerificationError) as exc_info:
                run_verification_gate(lld_path, project_root=project_root)

            assert exc_info.value.error_type == "not_approved"

    def test_raises_for_missing_file(self):
        """Gate raises LLDVerificationError for missing file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            project_root = Path(tmpdir)
            lld_path = project_root / "does_not_exist.md"

            with pytest.raises(LLDVerificationError) as exc_info:
                run_verification_gate(lld_path, project_root=project_root)

            assert "not found" in exc_info.value.reason

    def test_security_blocks_path_traversal(self):
        """Gate blocks path traversal attempts."""
        with tempfile.TemporaryDirectory() as tmpdir:
            project_root = Path(tmpdir)
            # Try to escape project root
            malicious_path = project_root / ".." / ".." / "etc" / "passwd"

            with pytest.raises(ValueError) as exc_info:
                run_verification_gate(malicious_path, project_root=project_root)

            assert "outside project root" in str(exc_info.value)


class TestLLDVerificationError:
    """Tests for LLDVerificationError exception."""

    def test_error_has_all_attributes(self):
        """Error contains reason, suggestion, and error_type."""
        error = LLDVerificationError(
            reason="Test reason",
            suggestion="Test suggestion",
            error_type="not_approved"
        )

        assert error.reason == "Test reason"
        assert error.suggestion == "Test suggestion"
        assert error.error_type == "not_approved"
        assert "Test reason" in str(error)
        assert "Test suggestion" in str(error)
```
